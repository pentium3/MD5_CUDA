
　
 	技术文档(Document)	
　	
作者：eCool

　
　	
MD5算法研究

　
　	
综述

　　MD5的全称是message-digest algorithm 5（信息-摘要算法），在90年代初由mit laboratory for computer science和rsa data security inc的ronald l. rivest开发出来，经md2、md3和md4发展而来。它的作用是让大容量信息在用数字签名软件签署私人密匙前被"压缩"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。不管是md2、md4还是md5，它们都需要获得一个随机长度的信息并产生一个128位的信息摘要。虽然这些算法的结构或多或少有些相似，但md2的设计与md4和md5完全不同，那是因为md2是为8位机器做过设计优化的，而md4和md5却是面向32位的电脑。这三个算法的描述和c语言源代码在internet rfcs 1321中有详细的描述（http://www.ietf.org/rfc/rfc1321.txt），这是一份最权威的文档，由ronald l. rivest在1992年8月向ieft提交。 

　　rivest在1989年开发出md2算法。在这个算法中，首先对信息进行数据补位，使信息的字节长度是16的倍数。然后，以一个16位的检验和追加到信息末尾。并且根据这个新产生的信息计算出散列值。后来，rogier和chauvaud发现如果忽略了检验和将产生md2冲突。md2算法的加密后结果是唯一的--既没有重复。 

　　为了加强算法的安全性，rivest在1990年又开发出md4算法。md4算法同样需要填补信息以确保信息的字节长度加上448后能被512整除（信息字节长度mod 512 = 448）。然后，一个以64位二进制表示的信息的最初长度被添加进来。信息被处理成512位damg?rd/merkle迭代结构的区块，而且每个区块要通过三个不同步骤的处理。den boer和bosselaers以及其他人很快的发现了攻击md4版本中第一步和第三步的漏洞。dobbertin向大家演示了如何利用一部普通的个人电脑在几分钟内找到md4完整版本中的冲突（这个冲突实际上是一种漏洞，它将导致对不同的内容进行加密却可能得到相同的加密后结果）。毫无疑问，md4就此被淘汰掉了。 

　　尽管md4算法在安全上有个这么大的漏洞，但它对在其后才被开发出来的好几种信息安全加密算法的出现却有着不可忽视的引导作用。除了md5以外，其中比较有名的还有sha-1、ripe-md以及haval等。 

　　一年以后，即1991年，rivest开发出技术上更为趋近成熟的md5算法。它在md4的基础上增加了"安全-带子"（safety-belts）的概念。虽然md5比md4稍微慢一些，但却更为安全。这个算法很明显的由四个和md4设计有少许不同的步骤组成。在md5算法中，信息-摘要的大小和填充的必要条件与md4完全相同。den boer和bosselaers曾发现md5算法中的假冲突（pseudo-collisions），但除此之外就没有其他被发现的加密后结果了。 

　　van oorschot和wiener曾经考虑过一个在散列中暴力搜寻冲突的函数（brute-force hash function），而且他们猜测一个被设计专门用来搜索md5冲突的机器（这台机器在1994年的制造成本大约是一百万美元）可以平均每24天就找到一个冲突。但单从1991年到2001年这10年间，竟没有出现替代md5算法的md6或被叫做其他什么名字的新算法这一点，我们就可以看出这个瑕疵并没有太多的影响md5的安全性。上面所有这些都不足以成为md5的在实际应用中的问题。并且，由于md5算法的使用不需要支付任何版权费用的，所以在一般的情况下（非绝密应用领域。但即便是应用在绝密领域内，md5也不失为一种非常优秀的中间技术），md5怎么都应该算得上是非常安全的了。 

　　算法的应用 

　　md5的典型应用是对一段信息（message）产生信息摘要（message-digest），以防止被篡改。比如，在unix下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如： 

　　　md5 (tanajiya.tar.gz) = 0ca175b9c0f726a831d895e269332461 

　　这就是tanajiya.tar.gz文件的数字签名。md5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的md5信息摘要。如果在以后传播这个文件的过程中，无论文件的内容发生了任何形式的改变（包括人为修改或者下载过程中线路不稳定引起的传输错误等），只要你对这个文件重新计算md5时就会发现信息摘要不相同，由此可以确定你得到的只是一个不正确的文件。如果再有一个第三方的认证机构，用md5还可以防止文件作者的"抵赖"，这就是所谓的数字签名应用。 

　　md5还广泛用于加密和解密技术上。比如在unix系统中用户的密码就是以md5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成md5值，然后再去和保存在文件系统中的md5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。 

　　正是因为这个原因，现在被黑客使用最多的一种破译密码的方法就是一种被称为"跑字典"的方法。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用md5程序计算出这些字典项的md5值，然后再用目标的md5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 bytes），同时密码只能是字母和数字，共26+26+10=62个字符，排列组合出的字典的项数则是p(62,1)+p(62,2)….+p(62,8)，那也已经是一个很天文的数字了，存储这个字典就需要tb级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码md5值的情况下才可以。这种加密技术被广泛的应用于unix系统中，这也是为什么unix系统比一般操作系统更为坚固一个重要原因。 

　　算法描述 

　　对md5算法简要的叙述可以为：md5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 

　　在md5算法中，首先需要对信息进行填充，使其字节长度对512求余的结果等于448。因此，信息的字节长度（bits length）将被扩展至n*512+448，即n*64+56个字节（bytes），n为一个正整数。填充的方法如下，在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。然后，在在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的信息字节长度=n*512+448+64=(n+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。 

　　md5中有四个32位被称作链接变量（chaining variable）的整数参数，他们分别为：a=0x01234567，b=0x89abcdef，c=0xfedcba98，d=0x76543210。 

　　当设置好这四个链接变量后，就开始进入算法的四轮循环运算。循环的次数是信息中512位信息分组的数目。 

　　将上面四个链接变量复制到另外四个变量中：a到a，b到b，c到c，d到d。 

　　主循环有四轮（md4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。 
以一下是每次操作中用到的四个非线性函数（每轮一个）。 

　　　f(x,y,z) =(x&y)|((~x)&z) 
　　　g(x,y,z) =(x&z)|(y&(~z)) 
　　　h(x,y,z) =x^y^z 
　　　i(x,y,z)=y^(x|(~z)) 
　　　（&是与，|是或，~是非，^是异或） 

　　这四个函数的说明：如果x、y和z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。 
f是一个逐位运算的函数。即，如果x，那么y，否则z。函数h是逐位奇偶操作符。 

　　假设mj表示消息的第j个子分组（从0到15），
　　<<　ff(a,b,c,d,mj,s,ti)　表示　a=b+((a+(f(b,c,d)+mj+ti)
　　<<　gg(a,b,c,d,mj,s,ti)　表示　a=b+((a+(g(b,c,d)+mj+ti)
　　<<　hh(a,b,c,d,mj,s,ti)　表示　a=b+((a+(h(b,c,d)+mj+ti)
　　<<　ii(a,b,c,d,mj,s,ti)　表示　a=b+((a+(i(b,c,d)+mj+ti)
　　<<　这四轮（64步）是： 

　　第一轮 

　　　ff(a,b,c,d,m0,7,0xd76aa478) 
　　　ff(d,a,b,c,m1,12,0xe8c7b756) 
　　　ff(c,d,a,b,m2,17,0x242070db) 
　　　ff(b,c,d,a,m3,22,0xc1bdceee) 
　　　ff(a,b,c,d,m4,7,0xf57c0faf) 
　　　ff(d,a,b,c,m5,12,0x4787c62a) 
　　　ff(c,d,a,b,m6,17,0xa8304613) 
　　　ff(b,c,d,a,m7,22,0xfd469501) 
　　　ff(a,b,c,d,m8,7,0x698098d8) 
　　　ff(d,a,b,c,m9,12,0x8b44f7af) 
　　　ff(c,d,a,b,m10,17,0xffff5bb1) 
　　　ff(b,c,d,a,m11,22,0x895cd7be) 
　　　ff(a,b,c,d,m12,7,0x6b901122) 
　　　ff(d,a,b,c,m13,12,0xfd987193) 
　　　ff(c,d,a,b,m14,17,0xa679438e) 
　　　ff(b,c,d,a,m15,22,0x49b40821) 

　　第二轮 

　　　gg(a,b,c,d,m1,5,0xf61e2562) 
　　　gg(d,a,b,c,m6,9,0xc040b340) 
　　　gg(c,d,a,b,m11,14,0x265e5a51) 
　　　gg(b,c,d,a,m0,20,0xe9b6c7aa) 
　　　gg(a,b,c,d,m5,5,0xd62f105d) 
　　　gg(d,a,b,c,m10,9,0x02441453) 
　　　gg(c,d,a,b,m15,14,0xd8a1e681) 
　　　gg(b,c,d,a,m4,20,0xe7d3fbc8) 
　　　gg(a,b,c,d,m9,5,0x21e1cde6) 
　　　gg(d,a,b,c,m14,9,0xc33707d6) 
　　　gg(c,d,a,b,m3,14,0xf4d50d87) 
　　　gg(b,c,d,a,m8,20,0x455a14ed) 
　　　gg(a,b,c,d,m13,5,0xa9e3e905) 
　　　gg(d,a,b,c,m2,9,0xfcefa3f8) 
　　　gg(c,d,a,b,m7,14,0x676f02d9) 
　　　gg(b,c,d,a,m12,20,0x8d2a4c8a) 

　　第三轮 

　　　hh(a,b,c,d,m5,4,0xfffa3942) 
　　　hh(d,a,b,c,m8,11,0x8771f681) 
　　　hh(c,d,a,b,m11,16,0x6d9d6122) 
　　　hh(b,c,d,a,m14,23,0xfde5380c) 
　　　hh(a,b,c,d,m1,4,0xa4beea44) 
　　　hh(d,a,b,c,m4,11,0x4bdecfa9) 
　　　hh(c,d,a,b,m7,16,0xf6bb4b60) 
　　　hh(b,c,d,a,m10,23,0xbebfbc70) 
　　　hh(a,b,c,d,m13,4,0x289b7ec6) 
　　　hh(d,a,b,c,m0,11,0xeaa127fa) 
　　　hh(c,d,a,b,m3,16,0xd4ef3085) 
　　　hh(b,c,d,a,m6,23,0x04881d05) 
　　　hh(a,b,c,d,m9,4,0xd9d4d039) 
　　　hh(d,a,b,c,m12,11,0xe6db99e5) 
　　　hh(c,d,a,b,m15,16,0x1fa27cf8) 
　　　hh(b,c,d,a,m2,23,0xc4ac5665) 

　　第四轮 

　　　ii(a,b,c,d,m0,6,0xf4292244) 
　　　ii(d,a,b,c,m7,10,0x432aff97) 
　　　ii(c,d,a,b,m14,15,0xab9423a7) 
　　　ii(b,c,d,a,m5,21,0xfc93a039) 
　　　ii(a,b,c,d,m12,6,0x655b59c3) 
　　　ii(d,a,b,c,m3,10,0x8f0ccc92) 
　　　ii(c,d,a,b,m10,15,0xffeff47d) 
　　　ii(b,c,d,a,m1,21,0x85845dd1) 
　　　ii(a,b,c,d,m8,6,0x6fa87e4f) 
　　　ii(d,a,b,c,m15,10,0xfe2ce6e0) 
　　　ii(c,d,a,b,m6,15,0xa3014314) 
　　　ii(b,c,d,a,m13,21,0x4e0811a1) 
　　　ii(a,b,c,d,m4,6,0xf7537e82) 
　　　ii(d,a,b,c,m11,10,0xbd3af235) 
　　　ii(c,d,a,b,m2,15,0x2ad7d2bb) 
　　　ii(b,c,d,a,m9,21,0xeb86d391) 

　　常数ti可以如下选择： 

　　在第i步中，ti是4294967296*abs(sin(i))的整数部分，i的单位是弧度。(4294967296等于2的32次方) 
所有这些完成之后，将a、b、c、d分别加上a、b、c、d。然后用下一分组数据继续运行算法，最后的输出是a、b、c和d的级联。 

　　当你按照我上面所说的方法实现md5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。 

　　　md5 ("") = d41d8cd98f00b204e9800998ecf8427e 
　　　md5 ("a") = 0cc175b9c0f1b6a831c399e269772661 
　　　md5 ("abc") = 900150983cd24fb0d6963f7d28e17f72 
　　　md5 ("message digest") = f96b697d7cb7938d525a2f31aaf161d0 
　　　md5 ("abcdefghijklmnopqrstuvwxyz") = c3fcd3d76192e4007dfb496cca67e13b 
　　　md5 ("12345678901234567890123456789012345678901234567890123456789012345678901234567890") = 57edf4a22be3c955ac49da2e2107b67a 

　　如果你用上面的信息分别对你做的md5算法实例做测试，最后得出的结论和标准答案完全一样，那我就要在这里象你道一声祝贺了。要知道，我的程序在第一次编译成功的时候是没有得出和上面相同的结果的。 


　　MD5的安全性 

　　md5相对md4所作的改进： 

　　　1. 增加了第四轮； 

　　　2. 每一步均有唯一的加法常数； 

　　　3. 为减弱第二轮中函数g的对称性从(x&y)|(x&z)|(y&z)变为(x&z)|(y&(~z))； 

　　　4. 第一步加上了上一步的结果，这将引起更快的雪崩效应； 

　　　5. 改变了第二轮和第三轮中访问消息子分组的次序，使其更不相似； 

　　　6. 近似优化了每一轮中的循环左移位移量以实现更快的雪崩效应。各轮的位移量互不相同。	　
	 